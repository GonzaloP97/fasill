<div class="container"><h4>wmgu/3</h4><pre><code>wmgu(+ExpressionA, +ExpressionB, ?State)</code></pre><p>This predicate returns the weak most general unifier (wmgu) ?State of the expressions +ExpressionA and +ExpressionB.</p></div>
<div class="container"><h4>select_atom/4</h4><pre><code>select_atom(+Expression, ?ExprVar, ?Var, ?Atom)</code></pre><p>This predicate selects an atom ?Atom from the expression +Expression, where ?ExprVar is the expression +Expression with the variable ?Var instead of the atom ?Atom.</p></div>
<div class="container"><h4>select_expression/4</h4><pre><code>select_expression(+Expression, ?ExprVar, ?Var, ?Atom)</code></pre><p>This predicate selects an interpretable expression ?Atom from the expression +Expression, where ?ExprVar is the expression +Expression with the variable ?Var instead of the atom ?Atom.</p></div>
<div class="container"><h4>interpretable/1</h4><pre><code>interpretable(+Expression)</code></pre><p>This predicate succeeds when the expression +Expression can be interpreted (i.e., there is no atoms in the expression).</p></div>
<div class="container"><h4>query/2</h4><pre><code>query(+Goal, ?Answer)</code></pre><p>This predicate succeeds when ?Answer is a fuzzy computed answer (fca) for the goal +Goal. A fca is a term of the form state(TD, Substitution), where TD is the truth degree.</p></div>
<div class="container"><h4>get_variables/2</h4><pre><code>get_variables(+Term, ?Variables)</code></pre><p>This predicate succeeds when ?Variables is the initial substitution for the term +Term, where each variable in +Term is replace by itself (X/X).</p></div>
<div class="container"><h4>derivation/4</h4><pre><code>derivation(+From, +State1, ?State2, ?Info)</code></pre><p>This predicate performs a complete derivation from an initial state ?State1 to the final state ?State2, using the program +Program. ?Info is a list containing the information of each step.</p></div>
<div class="container"><h4>inference/4</h4><pre><code>inference(+From, +State1, ?State2, ?Info)</code></pre><p>This predicate performs an inference step from the initial state +State1 to the final step ?State2. ?Info is an atom containg information about the rule used in the derivation.</p></div>
<div class="container"><h4>admissible_step/4</h4><pre><code>admissible_step(+From, +State1, ?State2, ?Info)</code></pre><p>This predicate performs an admissible step from the state +State1 to the state ?State2. ?Info is an atom containg information about the rule used in the derivation.</p></div>
<div class="container"><h4>success_step/4</h4><pre><code>success_step(+From, +State1, ?State2, ?Info)</code></pre><p>This predicate performs a successful admissible step from the state +State1 to the state ?State2. ?Info is an atom containg information about the rule used in the derivation.</p></div>
<div class="container"><h4>failure_step/3</h4><pre><code>failure_step(+State1, ?State2, ?Info)</code></pre><p>This predicate performs an unsuccessful admissible step from the state +State1 to the state ?State2. ?Info is an atom containg information about the failure.</p></div>
<div class="container"><h4>interpretive_step/3</h4><pre><code>interpretive_step(+State1, ?State2, ?Info)</code></pre><p>This predicate performs an interpretive step from the state +State1 to the state ?State2 ?Info is an atom containg information about the derivation. This steps only can be performed when there is no atoms to perform admissible steps.</p></div>
<div class="container"><h4>interpret/2</h4><pre><code>interpret(+Expression, ?Result)</code></pre><p>This predicate interprets the expression +Expression in the expression. ?Result is the resulting expression.</p></div>
<div class="container"><h4>rename/2</h4><pre><code>rename(+Expression, ?Renamed)</code></pre><p>This predicate renames the expression +Expression, replacing the variables of the expression by fresh variables. ?Renamed is the expression +Expression with fresh variables.</p></div>
<div class="container"><h4>compose/3</h4><pre><code>compose(+Substitution1, +Substitution2, ?SubstitutionOut)</code></pre><p>This predicate composes both substitutions, +Substitution1 and +Substitution2 in ?SubstitutionOut.</p></div>
<div class="container"><h4>apply/3</h4><pre><code>apply(+ExpressionIn, +Substitution, ?ExpressionOut)</code></pre><p>This predicate applies the substitution +Substitution to the expression +ExpressionIn. ?ExpressionOut is the resulting expression.</p></div>
<div class="container"><h4>arithmetic_evaluation/2</h4><pre><code>arithmetic_evaluation(+Expression, ?Result)</code></pre><p>This predicate succeeds when ?Result is the result of evaluating the expression +Expression. This predicate throws an arithmetical exception if there is any problem.</p></div>
<div class="container"><h4>arithmetic_type/2</h4><pre><code>arithmetic_type(+Number, ?Type)</code></pre><p>This predicate succeeds when +Number has the type ?Type (integer or float).</p></div>
<div class="container"><h4>arithmetic_op/2</h4><pre><code>arithmetic_op(+Operator, +Arguments, +Types, ?Result)</code></pre><p>This predicate succeeds when ?Result is the result of evaluating the operator +Operator with the arguments +Arguments with types +Types.</p></div>
<div class="container"><h4>current_fresh_variable_id/1</h4><pre><code>current_fresh_variable_id(?Identifier)</code></pre><p>This predicate stores the current identifier ?Identifier to be used in a fresh variable.</p></div>
<div class="container"><h4>auto_fresh_variable_id/1</h4><pre><code>auto_fresh_variable_id(?Identifier)</code></pre><p>This predicate updates the current variable identifier  ?Identifier and returns it.</p></div>
<div class="container"><h4>reset_fresh_variable_id/0</h4><pre><code>reset_fresh_variable_id</code></pre><p>This predicate resets the current ?Identifier identifier to the first.</p></div>